var lemonUtils = require("lemon_utils");
var pg = require("pg");

module.exports.PGConnection = function()
{
};
module.exports.PGConnection.prototype._pg = {};
module.exports.PGConnection.prototype.connect = function(callback)
{
	callback = callback || function()
	{
	};
	pg.connect("postgres://" + this.options.user + ":" + this.options.password + "@" + this.options.host + ":" + this.options.port + "/" + this.options.database, function(err, client, done)
	{
		if(err)
		{
			callback(err);
			return;
		}
		this._pg.client = client;
		this._pg.done = done;
		callback();
	}.bind(this));
};
module.exports.PGConnection.prototype.exec = function(query, params, callback)
{
	this._pg.client.query(query, params, function(error, result)
	{
		this._pg.done();
		if(error)
		{
			callback(error, null);
		}
		else
		{
			callback(null, result.rows);
		}
	}.bind(this));
};
module.exports.PGConnection.prototype.close = function()
{
	this._pg.client.end();
};
module.exports.PGQueryBuilder = function(engine)
{
	this.parts = {};
	this.parts.command = "select";
	this.parts.table = "";
	this.parts.columns = "*";
	this.parts.predicate = "";
};
module.exports.PGQueryBuilder.prototype.get = function()
{
	var parts = [this.parts.command];
	if(this.parts.command.toLowerCase() == "select")
	{
		parts.push(this.parts.columns);
		if(this.parts.table)
		{
			parts.push("from", this.parts.table);
		}
		if(this.parts.predicate)
		{
			parts.push("where", this.parts.predicate);
		}
	}
	console.log(parts.join(" "));
	return parts.join(" ");
};
module.exports.PGQueryBuilder.prototype.select = function(columns)
{
	this.parts.command = "select";
	if(columns.forEach)
	{
		this.parts.columns = columns.join(" ");
	}
	else
	{
		this.parts.columns = columns;
	}
	return this;
};
module.exports.PGQueryBuilder.prototype.table = function(table)
{
	this.parts.table = table;
	return this;
};
module.exports.PGQueryBuilder.prototype.where = function(predicate)
{
	this.parts.predicate = predicate;
	return this;
};
module.exports.PGConnection.prototype.builder = function()
{
	return new module.exports.PGQueryBuilder();
};
module.exports.PGConnection.prototype.predicate = function(predicateInput)
{
	var predicate = predicateInput;
	if(predicateInput == undefined)
	{
		predicate = "";
	}
	if(predicateInput.length > 1)
	{
		if(arguments.length == 2 && arguments[0].toLowerCase() != "is null" && arguments[0].toLowerCase() != "is not null")
		{
			predicate = arguments[0] + " = " + arguments[1];
		}
		else
		{
			predicate = "";
			var operator = arguments[1];
			[].forEach.call(arguments, function(arg, index)
			{
				if(predicate != "")
				{
					predicate += " ";
				}
				if(index == 2 && operator == "between")
				{
					predicate += arg[0] + " and " + arg[1];
				}
				else if(index == 2 && operator == "in")
				{
					predicate += "(" + arg.join(", ") + ")";
				}
				else
				{
					predicate += arg;
				}
			});
		}
	}
	return predicate;
};
module.exports.PGConnection.prototype.predicateOr = function(p1, p2, p3, etc)
{
	return "(" + [].join.call(arguments, ") or (") + ")";
};
module.exports.PGConnection.prototype.predicateAnd = function(p1, p2, p3, etc)
{
	return "(" + [].join.call(arguments, ") and (") + ")";
};